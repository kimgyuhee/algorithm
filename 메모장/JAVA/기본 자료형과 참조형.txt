<<<<< 기본 자료형과 참조형 >>>>>

# 학습목표
- 참조 타입과 값 타입의 이해
- String 클래스 사용법
- equals 메소드 재정의 방법
- instance of 연산자 사용법
- @Override 어노테이션 활용


---------------------------------------------------------------------------------------------------

## 내용을 보기 전 내가 아는 지식
- 참조 타입과 값 타입의 이해
	참조 타입은 메모리(변수)에 값의 주소를 저장하여 그 값을 가리키는 것이다.
	값 타입은 메모리(변수)에 그 값을 저장하는 것이다.
	참조 타입 : String, Java 클래스의 객체
	값 타입 : btye, double, int, shortm float, char, boolean

- String 클래스 사용법
	String은 immutable object 이므로 한번 저장한 값을 변경할 수 없다.
	그래서 값을 변형하고 싶으면 변수를 하나 더 생성하여 거기에 저장해야 한다.

- equals 메소드 재정의 방법
	모든 클래스는 Object 클래스의 자식 클래스 이므로 equals 메소드를 상속받아
	사용하는데, 그 Object 클래스의 equals 메소드는 identity 비교를 하기 때문에
	재정의 하여 equals 비교를 하게 만들어 줘야한다.

- instance of 연산자 사용법
	클래스가 부모인지 자식인지 boolean 참 거짓을 판별해 주는 연산자이다.

- @Override 어노테이션 활용
	@Override를 사용하면 재정의 할때 실수하면 오류를 발견하기 쉽다.



---------------------------------------------------------------------------------------------------

-> Java 웹서버 프로그래밍 (JSP) 프로젝트에서 클래스는 반드시 어떤 패키지 아래 있어야 한다.
	패키지가 정해지지 않은 클래스는 JSP 프로젝트에서 사용할 수 없다.

-> String 클래스의 문자열 수정 메소드는, this의 문자열을 수정하는 것이 아니고, 수정된 새 문자열
	객체를 리턴한다. this 문자열은 수정되지 않는다.

-> equality vs identity
	equality 비교 : 두 객체의 내부 값이 같은지 비교하는 것
	identity 비교 : 하나의 객체인지 비교하는 것

-> main 메소드가 호출되면, Stack Segment 영영에 main 메소드 메모리 공간이 할당된다.

-> Stack Segment 영역에 위치한 main 메소드의 메모리에는 지역 변수만 생성된다.

-> 객체들은 Heap Segment 영역에 생성된다.
	객체 // Student min = new Student();

-> 접근 제한자의 종료 : public, protected, private, default

-> 생성자도 오버로딩이 가능하므로 하나의 클래스에 여러 생성자가 가능
	모든 생성자가 리턴값이 없으므로 void를 생략

-> swap 메소드가 호출되면, Stack Segment 영역에 swap 메소드 메모리 공간이 할당된다.

-> instanceof 연산자는 객체가 속한 클래스를 확인할 때

-> JVM : java virtual machine의 약자
	자바는 운영체제에 의존적이다. 즉, 윈도우 jvm과 유닉스 jvm이 다르다는 것이다.
	Q. 그렇다면 윈도우에서 만든 자바 파일은 유닉스 혹은 리눅스에서 쓰지 못하는 것일까 ?
		A. 그걸 가능하게 하는 것이 JVM의 역할이다.
		한번 컴파일된 코드는 서로 다른 jvm 이더라고 돌아가도록 설계가 되어있다.

	JVM은 크게 3가지로 나뉘어진다.
		1) Class loader : 먼저 Class loader란 런타임시점(실행)에서 
			클래스파일로 로딩(메모리에 적재)하도록 도와준다.
		2) Runtime Data Access : 메모리 관련된 부분으로서 위레 메모리에 적재를 받은
			공간안에 PC 레지스터, Stack 영역, Method 영역, heap 영역, 네이티브
			메소드 스텍 5개의 영역으로 나뉜다.
		3) Excution Engine : 위 2개가 적재를 담당한다면 본격적으로 실행을 도와주는 친구
		
		Class Loader : 메모리 적재
		Runtime Data Areas : 각 영역 관리
		Excution Engine : 자바 바이트 코드 읽고 실행

-> JRE : java runtime environment 자바 실행 환경
	위에 JVM에서 실행을 할 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있다

-> JDK : Java SW development kit
	jre외에 개발을 위해 필요한 도구들을 가지고 있다.
	이 부분이 컴파일러를 들고 있는 자바 코드를 클래스 파일로 만들어 준다.






\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

<<<<< 기본 자료형 클래스 >>>>>

# 학습목표
- 업캐스팅과 다운캐스팅을 이해한다.
- 배열 객체 메모리 구조를 이해한다.
- 기본 자료형과 클래스를 사용하는 이유를 이해한다.
- autoboxing, unboxing 개념을 이해한다.
- 정적 멤버(static member) 개념과 구현 방법을 이해한다.


---------------------------------------------------------------------------------------------------

## 내용을 보기 전 내가 아는 지식

- 업캐스팅과 다운캐스팅을 이해한다.
	업캐스팅은 Object 변수에 내가 만든 객체가 들어가는게 허용되는 것
	다운캐스팅은 Person 변수에 부모 객체가 들어가는 것이다 // 오류

- 배열 객체 메모리 구조를 이해한다.
	main 클래스가 Stack Semeget 메모리에 저장되고 배열 객체의 주소가 main에
	저장되고 heap Segment에 배열 객체가 저장된다
	배열은 참조형만 저장할 수 있다. 

- 기본 자료형과 클래스를 사용하는 이유를 이해한다.
	변수 값을 메모리에 저장하기 위해 기본 자료형을 사용하고, 참조를 저장하기 위해서는
	클래스를 이용한다. 참조를 저장하려는 이유는 값 변경을 위하여

- autoboxing, unboxing 개념을 이해한다.
	autoboxing : Integer 변수에 int 값을 넣으면 그 값이 참조 값으로 변하는것
	unboxing : int 변수에 Integer 를 대입할 때 int 기본 자료형으로 변하는 것

- 정적 멤버(static member) 개념과 구현 방법을 이해한다.
	static member 변수를 값이 변하지 않고, 어느 메소드에서든 사용 가능하다.


---------------------------------------------------------------------------------------------------


-> 기본 자료형에 대한 껍데기 클래스라고 부른다 : wrapper class

-> 기본 자료형 값이 들어있는 껍데기 객체를 자동으로 생성해 주는 기능이라서, 껍데기
	객체를 상자(box)라고 보고 autoboxing이라고 이름을 붙였다.

-> null 값은 아무것도 참조하지 않는다는 뜻이다.
	Java의 기본형 int 변수에는 null을 대입할 수 없지만, 데이터베이스의 int 타입 필드
	에는 null을 저장할 수 있다. null 값이 가능한 int 값을 java 변수에 대입하려면
	기본 자료형 int 변수를 사용할 수 없고 Integer 객체 참조 변수를 사용해야 한다.
	
-> 클래스의 객체를 (객체) 인스턴스라고 부르기도 한다.

-> Fraction.java
	1. n, d 멤버 변수는 인스턴스 멤버 변수이다.
	인스턴스 멤버 변수는 객체 인스턴스 메모리 안에 만들어진다.
	즉, 객체 인스턴스마다 인스턴스 멤버 변수를 따로 소유한다

	 2. instanceCount 멤버 변수는 static 멤버 변수이다.
	static 멤버 변수를 클래스 멤버 변수라고 부른다.
	static 멤버 변수는 클래스에 한 개 만들어져서, 그 클래스릐 모든 객체 인스턴스들에게 공유

	instanceCount 멤버 변수는 Franction 클래스의 객체 인스턴스 총 수를 세기 위한 변수이다.
	정수 하나만 저장하면 되므로 이 변수를 한 개 이상 만들 필요가 없다.
	객체 인스턴스는 메모리에서 heap segement 영역에 생성된다.
	인스턴스 멤버 변수는 객체 내부에 들어있으므로, 인스턴스 멤버 변수도 heap 영역에 위치

	static 멤버 변수는 data segment 영역에 생성된다.
	C 언어의 전역 변수와 static 지역 변수도 data segment 영역에 생성된다

		Q. 지역 변수란 ?
			A.  { } 안에 생성되며 { } 을 벗어나면 사라진다. 메소드안에서 쓰이는 변수
			vs 전역변수(객체(인스턴스)변수, 클래스(static)변수)
			인스턴스 변수는 객체가 생성될 때 객체 인스턴스 메모리 안에 생긴다.
			클래스 변수는 모든 클래스에서 사용가능하며 data 영역에 저장됨

	3. Fraction 객체가 생성될 때, 생성자가 instanceCount 변수 값을 1 증가시킨다.
	따라서 instanceCount 변수 값은 생성된 Fraction 객체 인스턴스 수와 같다.

-> static 메소드의 제약은 this를 사용할 수 없다는 것이다.
	this가 아닌 다른 객체 인스턴스 멤버 변수나 메소드는 사용할 수 있다.

-> static constructor : static 멤버 변수를 초기화하는 코드는 static constructor 에 구현한다.
	* constructor : 생성자
	instance 생성자는 객체 인스턴스가 생성될 때마다 호출되지만.
	static 생성자는 한번만 호출된다.

	static 생성자는 main 메소드보다 먼저 호출된다.
	static 생성자가 포함된 클래스가 사용되지 전에 먼저 static 생성자가 호출된다.


	




\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
