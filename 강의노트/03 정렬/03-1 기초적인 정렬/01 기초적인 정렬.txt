정렬(Sort)

기초적인 정렬 알고리즘

# 학습목표 #
- 기본적인 정렬 알고리즘을 이해한다.
- 선택 정렬, 버블 정렬, 삽입 정렬
- 정렬의 수행시간을 분석한다.

1. 선택 정렬 (selection sort)

1) 개요
 -> 최소값을 선택해서 이동한다.

2) 절차
	i=0
	i 위치부터 끝까지 최소값을 찾는다.
	최소값을 i위치로 이동한다.

	i=1
	i 위치부터 끝까지 최소값을 찾는다.
	최소값을 i위치로 이동한다.

	i가 배열의 크기-2 만큼 위의 코드를
	반복한다.

3) 요약
가장 작은 값을 찾아서 0위치에 놓느다.
그 다음 작은 값을 찾아서 1 위치에 놓는다.
그 다음 작은 값을 찾아서 2 위치에 놓는다.
. . .
for(int i=0; i<a.length-1; i++) {
	배열 a의 i부터 끝까지 최소값을 찾는다
	최소값과 i의 위치를 서로 바꾼다.
}


2. 선택 정렬 구현 실습


****************************************************************


3. 버블 정렬

1) 절차
	입력 : 17 / 14 / 11 / 19 / 13 / 15 

	0부터 i-1까지, 두 쌍의 값을 비교하여, 왼쪽 값이 크면 서로 위치를 바꾼다.

	i=5
	-> 0부터 5 까지의 최대 값이 5 위치에 있다

	i=4
	-> 0부터 4 까지의 최대 값이 4 위치에 있다
	
	- - - 

2) 요약
for ( int i=a.length - 1 ; i>=1; i-- ) {
	for ( int j =0; j<i ; i++ ) {
		if ( a[j] > a [j+1] )
			swap(a, j, j+1);
	}
}

3) 버블 정렬 개선
위 절차에서 i=2 단계에서 이미 배열이 정렬되어 있다.
이렇게 이미 배열의 정렬이 끝난 경우에, 무의미한 반복을 계속하지 않고, 종료할 수 있도록 개선하자

for ( int i =a.length -1 ; i >=1; i--) {
	boolean finish = true;
	for ( int j=0; j < i ; i++ ) {
		if ( a[j] > a [j+1] ) {
			swap(a, j, j+1);
			finish = false;
		}
	}
	if (finish)
		break;
}


개선된 버블 정렬의 수행시간
입력 배열의 크기가 N이고 C는 상수

이미 거의 다 정렬되어 있고, 최대 (N*1/C)개의 항목만 순서가 틀어져 있다면 -> O(n2)
최대 C개의 항목만 순서가 틀어져있다면 -> O(n)


****************************************************************


5. 삽입 정렬

1) 배열 입력

2) 절차
i=1
i 위치의 값을 앞부분의 적당한 위치에 끼워 넣는다

3) 요약
void insertionSort ( int [] a ) {
	for ( int i=1; i < a.length; i++) {
		int value=a[i];
		a 배열의 0에서 i-1 사이에서 value보다 큰 값들을 뒤로
		한칸씩 이동하고, 그 값들 앞에 value를 넣는다.
	}
}


6. 삽입 정렬 구현

1) 구현

	static void insertionSort( int [] a ) {
		for(int i =1; i<a.length; i++) {
			int value=a[i];
			int j;
			for(int j=i-1 ; j>=0; j--) {
				if ( a[j] >value )
					a[j+1]=a[j];
				else
					break;
			}
			a[j+1]=value;
		}

	}





